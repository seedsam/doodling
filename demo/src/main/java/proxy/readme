// 代理
// 缺陷:如果是final类的话无法继承,final方法的话无法重写,原方法没有实现接口的话无法实现
// 基于代理模式,有静态代理和动态代理两种方式,还有一种就是反射
//   静态代理方式:属于硬编码方式,继承.实现重写方法
//   动态代理:分为JDK动态代理和CGLIB动态代理
//      jdk动态代理方式:implements,只能代理接口,反射    代理类其实继承了Proxy类
//      CGLIB动态代理方式:extends,

// 问题基于缺陷,代理如果使用反射的话是否就能实现代理呢?
// ===================
// 为什么jdk动态代理只能实现接口,而不能继承呢?
// ====================
//
// =================================

/*
 * 总结：
 *  1.JDK代理使用的是反射机制实现aop的动态代理，CGLIB代理使用字节码处理框架asm，通过修改字节码生成子类。
 *    所以jdk动态代理的方式创建代理对象效率较高，执行效率较低，
 *    cglib创建效率较低，执行效率高；
 *  2.JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托hanlder去调用原始实现类方法，
 *    CGLIB则使用的继承机制，具体说被代理类和代理类是继承关系，
 *    所以代理类是可以赋值给被代理类的，如果被代理类有接口，那么代理类也可以赋值给接口。
 */
 
 
 
 
 
 
 
 
 
 