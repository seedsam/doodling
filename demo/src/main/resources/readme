代理
	缺陷:如果是final类的话无法继承,final方法的话无法重写,原方法没有实现接口的话无法实现
	基于代理模式,有静态代理和动态代理两种方式,还有就是反射
	静态代理的代理关系在编译时确定，而动态代理的代理关系在运行时确定，动态代理更灵活
  		静态代理
   			属于硬编码方式,继承重写方法
  			AspectJ属于静态代理,因为是在编译时做的增强
  		动态代理
  			分为JDK动态代理和CGLIB动态代理
     			jdk动态代理	implements
     			CGLIB动态代理	extends+implements

相关问题
	代理如果使用纯反射的话是否能够实现代理呢?
	答案是可以
		为什么又不这样做呢?
		==具体原因还是不清晰,需要自己手动写一个demo
相关联主题
	回调函数
		方法的演变
		基于消息和事件的架构模型(异步回调)
	模板方法
	好莱坞原则	Don't call me,we will call you.
	控制反转?
===================
jdk动态代理
	相关类和接口
  		Proxy
    	public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
    		throws IllegalArgumentException
      InvocationHandler
        public Object invoke(Object proxy, Method method,Object[]args)throws Throwable
    	通过该方法生成字节码，动态的创建一个代理类，interfaces参数是该动态类所继承的所有接口
	          实现InvocationHandler的类是在调用代理接口方法前后的具体逻辑
	        1.生成一个实现了参数interfaces里所有接口且继承了Proxy的代理类的字节码，然后用参数里的classLoader加载这个代理类
	        2.使用代理类父类的构造函数Proxy(InvocationHandler h)来创造一个代理类的实例，将我们自定义的InvocationHandler的子类传入
	        3.返回这个代理类实例
	查看动态代理生成的字节码文件
  		在main方法中加入System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true")
  		这样就会把生成的代理类class文件保存在本地磁盘上,再反编译可以得到代理类的源码
  	缺点
		需要目标对象实现一个或多个接口，对于没有实现接口的类，无法通过这种方式实现动态代理
			通过接口的方式有两个弊端
		      	一是必须保证target类有接口
		      	二是如果想要对target类的方法进行代理拦截，那么就要保证这些方法都要在接口中声明，实现上略微有点限制
    	会为接口中的声明的所有方法添加上相同的代理逻辑，不够灵活
相关问题
	为什么jdk动态代理只能代理实现接口的类?
	jdk动态代理为什么要继承Proxy?
	Object proxy参数的作用是什么?
		1.可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()）
		2.可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象
====================
cglib动态代理
	cglib - Byte Code Generation Library is high level API to generate and transform Java byte code. 
	It is used by AOP, testing, data access frameworks to generate dynamic proxy objects and intercept field access.
		支持接口、继承方式实现代理
  	原理:动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法
  		在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势将横切逻辑织入（weave）目标对象
  		CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类
	该设置用于输出cglib动态代理产生的类
  		System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "C:\\class");
  	Cglib动态代理执行代理方法效率之所以比JDK的高是因为Cglib采用了FastClass机制
  		它的原理简单来说就是：为代理类和被代理类各生成一个class，这个class会为代理类或被代理类的方法分配一个index(int类型)。
		这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高
相关问题
		

=================================
总结：
	1.JDK代理使用的是反射机制实现aop的动态代理，CGLIB代理使用字节码处理框架asm，通过修改字节码生成子类。
		jdk动态代理的方式创建代理对象效率较高，执行效率较低，
    	cglib创建效率较低，执行效率高；
  	2.JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托hanlder去调用原始实现类方法，
      CGLIB则使用的继承机制，具体说被代理类和代理类是继承关系
		所以代理类是可以赋值给被代理类的，如果被代理类有接口，那么代理类也可以赋值给接口。
	两种动态代理方式的比较
		JDK动态代理不需要任何外部依赖，但是只能基于接口进行代理；
		CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，
			但是无法代理final对象与final方法。（final类型不能有子类，final方法不能被重载）
	最后我们总结一下JDK动态代理和Gglib动态代理的区别：
		1.JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
		2.JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
		3.JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
======================================= 
理解
	单纯对于两种动态代理来说,都是用的一样的套路,1.代理方法也就是回调函数重写2.组织构建代理对象,调用被代理方法
	这个套路的核心在于生成代理类的class文件,使得jvm能够正常加载
	生成的class文件时间不同,编译时和运行时
	生成的class文件内容不同,效率不同
	都是基于反射进行构建,代理方法显得就不那么重要了
	cglib使用范围广,灵活度高,故框架底层都会配备,jdk无须任何外部依赖,简单
	
	
 
 
 
 
 
 
 