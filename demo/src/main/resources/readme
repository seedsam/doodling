代理
	缺陷:如果是final类的话无法继承,final方法的话无法重写,原方法没有实现接口的话无法实现
	基于代理模式,有静态代理和动态代理两种方式,还有就是反射
      静态代理的代理关系在编译时确定，而动态代理的代理关系在运行时确定，动态代理更灵活
  		静态代理方式:属于硬编码方式,继承.实现重写方法
  		动态代理:分为JDK动态代理和CGLIB动态代理
     		jdk动态代理方式:implements,只能代理接口,反射    代理类其实继承了Proxy类
     		CGLIB动态代理方式:extends

相关问题
	代理如果使用纯反射的话是否能够实现代理呢?
	答案是可以
		为什么又不这样做呢?
		==具体原因还是不清晰,需要自己手动写一个demo
		
===================
jdk动态代理
	相关类和接口
  		Proxy
    	public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
    		throws IllegalArgumentException
      InvocationHandler
        public Object invoke(Object proxy, Method method,Object[]args)throws Throwable
    	通过该方法生成字节码，动态的创建一个代理类，interfaces参数是该动态类所继承的所有接口
	          实现InvocationHandler的类是在调用代理接口方法前后的具体逻辑
	        1.生成一个实现了参数interfaces里所有接口且继承了Proxy的代理类的字节码，然后用参数里的classLoader加载这个代理类
	        2.使用代理类父类的构造函数Proxy(InvocationHandler h)来创造一个代理类的实例，将我们自定义的InvocationHandler的子类传入
	        3.返回这个代理类实例
	查看动态代理生成的字节码文件
  		在main方法中加入System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true")
  		这样就会把生成的代理类class文件保存在本地磁盘上,再反编译可以得到代理类的源码
  	缺点
		需要目标对象实现一个或多个接口，对于没有实现接口的类，无法通过这种方式实现动态代理
			通过接口的方式有两个弊端
		      	一是必须保证target类有接口
		      	二是如果想要对target类的方法进行代理拦截，那么就要保证这些方法都要在接口中声明，实现上略微有点限制
    	会为接口中的声明的所有方法添加上相同的代理逻辑，不够灵活
相关问题
	为什么jdk动态代理只能代理实现接口的类?
	jdk动态代理为什么要继承Proxy?
	Object proxy参数的作用是什么?
		1.可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()）
		2.可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象
====================
cglib动态代理
	cglib - Byte Code Generation Library is high level API to generate and transform Java byte code. 
	It is used by AOP, testing, data access frameworks to generate dynamic proxy objects and intercept field access.
		支持接口、继承方式实现代理
  	原理:动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法
  		在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势将横切逻辑织入（weave）目标对象
  		CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类
	该设置用于输出cglib动态代理产生的类
  		System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "C:\\class");
  	Cglib动态代理执行代理方法效率之所以比JDK的高是因为Cglib采用了FastClass机制
  		它的原理简单来说就是：为代理类和被代理类各生成一个class，这个class会为代理类或被代理类的方法分配一个index(int类型)。
		这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高
	
相关问题
	

=================================
总结：
	1.JDK代理使用的是反射机制实现aop的动态代理，CGLIB代理使用字节码处理框架asm，通过修改字节码生成子类。
		jdk动态代理的方式创建代理对象效率较高，执行效率较低，
    	cglib创建效率较低，执行效率高；
  	2.JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托hanlder去调用原始实现类方法，
      CGLIB则使用的继承机制，具体说被代理类和代理类是继承关系
		所以代理类是可以赋值给被代理类的，如果被代理类有接口，那么代理类也可以赋值给接口。
	两种动态代理方式的比较
		JDK动态代理不需要任何外部依赖，但是只能基于接口进行代理；
		CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，
			但是无法代理final对象与final方法。（final类型不能有子类，final方法不能被重载）
	最后我们总结一下JDK动态代理和Gglib动态代理的区别：
		1.JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
		2.JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
		3.JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
 
======================================= 
自己的一些理解
	纯反射代理和静态代理其实是没有区别的,属于硬编码,笨重,耦合度高,效率低.重新审视了上面的一段话,是错误的.反射和静态代理是完全不同的.
	静态代理不是没有作用,是针对其中某一个类中的某一个方法的增强,属于小众
		如果是这样的话,项目前期可以直接修改源代码,后期的话,依赖性高,不适于修改,而只适合于扩展,,开闭原则
	动态代理的应用场景,批量添加重复性代码,例如:日志,事务,安全,
	方案:1.修改代码,方法出现大量重复代码
		2.静态代理,源代码不用修改,添加大量代理类,大量代理方法,大量重复代码
		3.动态代理,源代码不用修改,项目添加一个类就能完成一个功能,粒度大,类中所有方法都会生成功能,无法细化
		4.切面编程,源代码不用修改,切面粒度由类细化到方法

	反射的作用
	
	静态代理和动态代理的最大区别在于,动态代理是在运行时状态下根据传入的被代理对象生成对应的代理类,也就是生成新的字节码文件(.class文件)
		反射在动态代理中的作用是,根据传入的被代理对象,通过反射调用原方法,协助完成代理过程
	原对象和代理对象在框架中的获取,
 
 
 
 
 
 
 
 
 